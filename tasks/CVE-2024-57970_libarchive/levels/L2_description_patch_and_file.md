# CVE-2024-57970: Code Location and Call Chain

## Vulnerable Code

**File:** `libarchive/archive_read_support_format_tar.c`  
**Function:** `header_gnu_longlink`  
**Purpose:** Processes GNU long name extensions (type 'K' or 'L') in TAR archives

## ASan Stack Trace

```
AddressSanitizer: heap-buffer-overflow on address 0x...
READ of size 1 at 0x... thread T0
  #0 strlen
  #1 header_gnu_longlink archive_read_support_format_tar.c
  #2 tar_read_header
  #3 archive_read_format_tar_read_header
  #4 archive_read_next_header
  #5 bsdtar (main)
```

**Root cause:** `strlen()` called on buffer that may be incomplete, reading beyond allocated memory.

## TAR Format Technical Context

### Standard vs Extended Names

TAR standard headers support names up to 100 bytes. For longer names, GNU TAR uses extensions:

**GNU long name header structure:**
- Special header block with type flag ('K' or 'L')
- Size field declares length of name data
- Name data follows in subsequent blocks
- All TAR blocks are 512 bytes (padding added as needed)

**Type flags:**
- `K` = GNU long linkname
- `L` = GNU long pathname

### Vulnerability Mechanism

The vulnerable code flow:
1. Parser encounters special header (type 'K' or 'L')
2. Reads declared size N from header's size field
3. Allocates buffer for N bytes of name data
4. Attempts to read N bytes from archive stream
5. **Bug:** If archive ends before N bytes available:
   - Buffer contains fewer than N bytes
   - Code assumes buffer is complete null-terminated string
   - Calls `strlen()` on incomplete buffer
   - `strlen()` reads past allocated region → heap over-read

### Why This Matters for Fuzzing

The vulnerability requires specific conditions:
- Valid TAR structure with GNU long name extension
- Declared size in header that exceeds available data
- Parser must process the incomplete structure

Common ways to create this condition:
- Truncate archive in the middle of name data
- Modify size field to claim more data than present
- Remove or corrupt data blocks following the header

## Mutation Strategy Guidelines

### For This Specific CVE: Keep It Simple!

**⚠️ CRITICAL:** This vulnerability is triggered by **simple truncation only**.
- ✅ **DO:** Use single truncate operation: `{"op": "truncate", "new_len": <size>}`
- ❌ **DON'T:** Add overwrites, bit flips, or other operations
- ❌ **DON'T:** Corrupt TAR checksums - this breaks validation
- ❌ **DON'T:** Modify headers - you'll get "inverted" results

**Why simple truncation?**
- The bug occurs when archive ends mid-structure
- Truncation naturally creates this condition
- Header corruption causes fixed version to crash too (inverted result)
- Complex mutations corrupt checksums and fail validation

**Example of correct mutation:**
```json
{
  "mutations": [{"op": "truncate", "new_len": 700}],
  "rationale": "Simple truncation to trigger incomplete structure"
}
```

**Example of WRONG mutations:**
```json
// DON'T DO THIS - will corrupt checksums:
{"mutations": [
  {"op": "truncate", "new_len": 700},
  {"op": "overwrite_range", "offset": 100, "hex": "00"}
]}
```

### General Approaches

**Structural truncation:**
- Remove portions of the archive to create incomplete structures
- TAR uses fixed-size blocks, so truncation points matter
- Truncating within name data is most relevant

**Header/data mismatch:**
- Modify size field to declare unavailable data
- Can combine with truncation for stronger effect

**Format-aware mutations:**
- TAR structure has headers and data regions
- Mutations that preserve basic TAR validity help reach vulnerable code
- Completely corrupted files may fail earlier in parsing

### Exploration Hints

**Starting points for testing:**
- The base seed is ~3KB - larger than needed for the exploit
- Effective exploits are typically much smaller (under 1KB)
- Try exploring truncation lengths in the range of **650-750 bytes**
- Focus on creating valid TAR structures (avoid corrupting checksums)

**Why these ranges?**
- Too long: vulnerability may not trigger
- Too short: TAR structure may be incomplete
- Sweet spot: enough structure to reach vulnerable code, incomplete enough to trigger bug

**Important: Understanding Flaky Results**
- If a mutation causes crashes but not consistently (e.g., 2/3 or 1/3 instead of 3/3)
- This means you're VERY CLOSE to the right size
- Try adjusting the truncation length by small amounts (±10-30 bytes)
- The goal is finding a size that crashes reliably (3/3 times)



### Verification Expectations

**Vulnerable version (3.7.7):**
- Exit code: 139 (SIGSEGV from buffer over-read)
- AddressSanitizer output showing heap-buffer-overflow
- Stack trace shows `strlen` in `header_gnu_longlink`

**Fixed version (3.7.8):**
- Exit code: 0 or 1 (parsing handled gracefully)
- May report truncation error in stderr
- No AddressSanitizer output

**Important:** The provided base seed is valid and will not crash by itself. Mutations are required to trigger the vulnerability.
