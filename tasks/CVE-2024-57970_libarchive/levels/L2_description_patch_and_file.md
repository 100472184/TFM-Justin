# CVE-2024-57970: Code Location and Call Chain

## Vulnerable Code

**File:** `libarchive/archive_read_support_format_tar.c`  
**Function:** `header_gnu_longlink`  
**Purpose:** Processes GNU long name extensions (type 'K' or 'L') in TAR archives

## ASan Stack Trace

```
AddressSanitizer: heap-buffer-overflow on address 0x...
READ of size 1 at 0x... thread T0
  #0 strlen
  #1 header_gnu_longlink archive_read_support_format_tar.c
  #2 tar_read_header
  #3 archive_read_format_tar_read_header
  #4 archive_read_next_header
  #5 bsdtar (main)
```

**Root cause:** `strlen()` called on buffer that may be incomplete, reading beyond allocated memory.

## TAR Format Technical Context

### Standard vs Extended Names

TAR standard headers support names up to 100 bytes. For longer names, GNU TAR uses extensions:

**GNU long name header structure:**
- Special header block with type flag ('K' or 'L')
- Size field declares length of name data
- Name data follows in subsequent blocks
- All TAR blocks are 512 bytes (padding added as needed)

**Type flags:**
- `K` = GNU long linkname
- `L` = GNU long pathname

### Vulnerability Mechanism

The vulnerable code flow:
1. Parser encounters special header (type 'K' or 'L')
2. Reads declared size N from header's size field
3. Allocates buffer for N bytes of name data
4. Attempts to read N bytes from archive stream
5. **Bug:** If archive ends before N bytes available:
   - Buffer contains fewer than N bytes
   - Code assumes buffer is complete null-terminated string
   - Calls `strlen()` on incomplete buffer
   - `strlen()` reads past allocated region â†’ heap over-read

### Why This Matters for Fuzzing

The vulnerability requires specific conditions:
- Valid TAR structure with GNU long name extension
- Declared size in header that exceeds available data
- Parser must process the incomplete structure

Common ways to create this condition:
- Truncate archive in the middle of name data
- Modify size field to claim more data than present
- Remove or corrupt data blocks following the header

## Mutation Strategy Guidelines

### General Approaches

**Structural truncation:**
- Remove portions of the archive to create incomplete structures
- TAR uses fixed-size blocks, so truncation points matter
- Truncating within name data is most relevant

**Header/data mismatch:**
- Modify size field to declare unavailable data
- Can combine with truncation for stronger effect

**Format-aware mutations:**
- TAR structure has headers and data regions
- Mutations that preserve basic TAR validity help reach vulnerable code
- Completely corrupted files may fail earlier in parsing

### Exploration Hints

**Starting points for testing:**
- The base seed is ~10KB - significantly larger than needed
- Effective exploits are typically much smaller (under 1KB)
- Try exploring truncation lengths in the range of 600-800 bytes
- Focus on creating valid TAR structures (avoid corrupting checksums)

**Why these ranges?**
- Too long: vulnerability may not trigger
- Too short: TAR structure may be incomplete
- Sweet spot: enough structure to reach vulnerable code, incomplete enough to trigger bug

### Verification Expectations

**Vulnerable version (3.7.7):**
- Exit code: 139 (SIGSEGV from buffer over-read)
- AddressSanitizer output showing heap-buffer-overflow
- Stack trace shows `strlen` in `header_gnu_longlink`

**Fixed version (3.7.8):**
- Exit code: 0 or 1 (parsing handled gracefully)
- May report truncation error in stderr
- No AddressSanitizer output

**Important:** The provided base seed is valid and will not crash by itself. Mutations are required to trigger the vulnerability.
