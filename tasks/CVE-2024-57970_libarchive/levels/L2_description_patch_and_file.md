# CVE-2024-57970: Code Location and Call Chain

## Vulnerable Code

**File:** `libarchive/archive_read_support_format_tar.c`  
**Function:** `header_gnu_longlink`  
**Purpose:** Processes GNU long linkname extensions in TAR archives

## ASan Stack Trace (typical)

```
AddressSanitizer: heap-buffer-overflow
  #0 strlen (libc)
  #1 header_gnu_longlink (archive_read_support_format_tar.c)
  #2 tar_read_header
  #3 archive_read_format_tar_read_header
  #4 archive_read_next_header
  #5 bsdtar main loop
```
**Root cause:** `strlen()` called on incomplete buffer → reads past allocation

## TAR Format Context

**GNU long linkname structure:**
1. Special header with type flag 'K' or 'L'
2. Size field indicates linkname length
3. Linkname data follows in subsequent blocks (512-byte aligned)

**Vulnerable scenario:**
- Archive declares long linkname of N bytes
- Actual data < N bytes (truncated)
- Code reads declared N bytes without validation → heap over-read

## Mutation Approach

**General strategies:**
1. **Truncation:** Remove data after header to create incomplete structures ⭐ (Most effective - USE THIS)
2. **Size mismatch:** Declare one size but provide different amount of data (less effective)
3. **Boundary conditions:** Test edge cases around block sizes and string termination (less effective)
4. **Format corruption:** Modify headers to create inconsistent states (can prevent crash)

**⚠️ CRITICAL: For this CVE, use ONLY truncation mutation**

**Effective approach from validated exploits:**
- Simple truncation ALONE is sufficient - DO NOT add other mutations
- Successful exploit sizes: 768 bytes ⭐, ~1,500 bytes, and ~3,000 bytes (much smaller than base)
- Block boundaries (multiples of 512) are good truncation points
- Adding overwrites, bit flips, or repeats damages the TAR structure and prevents the crash

**Mutation order matters:**
- Mutations are applied sequentially in the order specified
- ✅ CORRECT: `[{"op": "truncate", "new_len": 768}]` - Truncate only
- ❌ WRONG: `[{"op": "overwrite_range", ...}, {"op": "truncate", ...}]` - Don't add overwrites
- ❌ WRONG: Multiple mutations that damage TAR structure

**Best approach:** Start with base.tar (10,240 bytes), truncate to known working size
```json
{"mutations": [{"op": "truncate", "new_len": 768}]}
```

## Verification

**Vulnerable (3.7.7):**  
- Exit code: **139** (SIGSEGV from heap-buffer-overflow)
- stderr: `AddressSanitizer: heap-buffer-overflow` OR `Segmentation fault`

**Fixed (3.7.8):**  
- Exit code: **1** (parsing error handled gracefully)
- stderr: no ASan output, error message about truncation

**Note:** A valid base seed (10,240 bytes, type 'L' longlink) processes cleanly on both versions (exit_code=0). The vulnerability is triggered by **truncating** this seed during fuzzing.

**Known working exploit sizes:** 
- 1,471 bytes (official PoC)
- 3,072 bytes (validated truncation)
Both significantly smaller than the 10,240-byte base seed.

