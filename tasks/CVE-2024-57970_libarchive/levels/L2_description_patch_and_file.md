# CVE-2024-57970: Code Location and Call Chain

## Vulnerable Code

**File:** `libarchive/archive_read_support_format_tar.c`  
**Function:** `header_gnu_longlink`  
**Purpose:** Processes GNU long linkname extensions in TAR archives

## ASan Stack Trace (typical)

```
AddressSanitizer: heap-buffer-overflow
  #0 strlen (libc)
  #1 header_gnu_longlink (archive_read_support_format_tar.c)
  #2 tar_read_header
  #3 archive_read_format_tar_read_header
  #4 archive_read_next_header
  #5 bsdtar main loop
```
**Root cause:** `strlen()` called on incomplete buffer → reads past allocation

## TAR Format Context

**GNU long linkname structure:**
1. Special header with type flag 'K' or 'L'
2. Size field indicates linkname length
3. Linkname data follows in subsequent blocks (512-byte aligned)

**Vulnerable scenario:**
- Archive declares long linkname of N bytes
- Actual data < N bytes (truncated)
- Code reads declared N bytes without validation → heap over-read

## Mutation Approach

**General strategies:**
1. **Truncation:** Remove data after header to create incomplete structures
2. **Size mismatch:** Declare one size but provide different amount of data
3. **Boundary conditions:** Test edge cases around block sizes and string termination
4. **Format corruption:** Modify headers to create inconsistent states

## Verification

**Vulnerable (3.7.7):**  
- Exit code: **139** (SIGSEGV from heap-buffer-overflow)
- stderr: `AddressSanitizer: heap-buffer-overflow`

**Fixed (3.7.8):**  
- Exit code: **1** (parsing error handled gracefully)
- stderr: no ASan output, error message about truncation

**Note:** A valid base seed (10,240 bytes, type 'L' longlink) processes cleanly on both versions (exit_code=0). The vulnerability is triggered by **truncating** this seed during fuzzing.

