# CVE-2024-57970: Complete Technical Context

## Official Advisory Summary

**CVE ID:** CVE-2024-57970  
**Type:** Heap-based buffer over-read (CWE-126)  
**Component:** libarchive TAR reader  
**Function:** `header_gnu_longlink` in `libarchive/archive_read_support_format_tar.c`  
**Trigger:** Truncation in GNU long linkname during TAR parsing

**References:**
- NVD: CVE-2024-57970
- Upstream Issue: libarchive #2415 (ASan report)
- Upstream Fix: PR #2422 (merged Dec 10, 2024)
- Fixed Release: libarchive 3.7.8

## Technical Deep Dive

### GNU Long Linkname Format

TAR standard headers support 100-byte names. GNU extension for longer names:
```
[Header Block: type='K'/'L', size=N]
[Data Block(s): N bytes of linkname, null-terminated]
[Padding to 512-byte boundary]
```

**Type flags:**
- `K` = GNU long linkname
- `L` = GNU long pathname

### Vulnerability Mechanics

**Code flow in `header_gnu_longlink`:**
1. Read special header indicating long linkname
2. Extract declared size N from header
3. Allocate buffer for N bytes
4. Read N bytes from archive
5. **BUG:** If archive truncates before N bytes available:
   - Buffer contains < N bytes
   - Code calls `strlen()` assuming complete null-terminated string
   - `strlen()` reads past buffer end  heap over-read

### Precise Mutation Strategies

**CRITICAL: Start with valid TAR containing GNU long linkname**

**Base seed requirements:**
```
Offset 0-511:    Header with type='K', size=250, filename="././@LongLink"
Offset 512-1023: Long linkname data (250 bytes, null-terminated)
Offset 1024+:    Regular file header + data + EOF markers
Total: ~3KB valid TAR
```

**Mutation targets to trigger heap over-read:**
1. **Truncate at block boundary:**
   - `{"op": "truncate", "new_len": 768}` → Cuts mid-linkname data
   - `{"op": "truncate", "new_len": 600}` → Incomplete linkname

2. **Truncate just before null terminator:**
   - `{"op": "truncate", "new_len": 761}` → strlen() reads past end

3. **Corrupt size field but keep data:**
   - Overwrite header size (offset 124-135) to declare MORE bytes than available
   - Example: Change "0000000372" to "0000001000" but truncate data at 768

**Effective mutation sequence:**
```json
{
  "mutations": [
    {"op": "truncate", "new_len": 768}
  ]
}
```

**High-value truncation offsets:**
1. **Mid-payload:** `512 + (declared_size / 2)` = ~637
2. **Block boundary:** `512 + 256` = 768
3. **Just before terminator:** `512 + declared_size - 1` = 761
4. **Early truncation:** `512 + 50` = 562

### Benchmark Environment
- Base: Ubuntu 22.04
- Compiler: Clang with `-fsanitize=address,undefined`
- Command: `bsdtar -tf /input/seed.bin`
- Timeout: 10 seconds

### Expected Outcomes
**Vulnerable (3.7.7):** Exit code non-zero, stderr contains `AddressSanitizer: heap-buffer-overflow`  
**Fixed (3.7.8):** Clean exit or parsing error, no ASan output

### Iterative Fuzzing Guidance

**Phase 1 (iter 1-3):** Use valid base.tar with GNU long linkname (provided in seeds/)  
**Phase 2 (iter 4-7):** Apply precise truncations at offsets 562, 637, 761, 768  
**Phase 3 (iter 8-10):** Refine successful crash offsets with ±10 byte adjustments

**Validation checklist per iteration:**
- ✅ Seed starts with valid TAR header (magic "ustar\0" at offset 257)
- ✅ Header type flag is 'K' (0x4B) at offset 156
- ✅ Size field declares linkname length at offset 124-135
- ✅ Truncation happens WITHIN linkname data block (offsets 512-1024)

**Success criteria:**
- Vulnerable (3.7.7): Exit code 139 (SIGSEGV), stderr contains "AddressSanitizer: heap-buffer-overflow"
- Fixed (3.7.8): Exit code 0 or 1 (parsing error), NO ASan output

**File format note:**
- Seed can be .bin or .tar (bsdtar accepts both)
- Pipeline automatically detects TAR format from header magic
- Use base.tar from seeds/ directory as starting point
