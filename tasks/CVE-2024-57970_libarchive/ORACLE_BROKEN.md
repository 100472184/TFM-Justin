# CVE-2024-57970 Oracle Status: BROKEN

## Problem Summary

**The vulnerability is NOT being detected by AddressSanitizer**, despite correct compilation and Docker setup.

## Evidence

### 1. ASan is Compiled In
```bash
docker run --rm --entrypoint bash cve-2024-57970_libarchive-target-vuln -c "strings /opt/target/bin/bsdtar | grep -i asan"
# Output: __asan_report_store4, __asan_poison_cxx_array_cookie, etc.
```

### 2. Binary Versions Are Correct
```bash
docker run --rm --entrypoint /opt/target/bin/bsdtar cve-2024-57970_libarchive-target-vuln --version
# Output: bsdtar 3.7.7 - libarchive 3.7.7

docker run --rm --entrypoint /opt/target/bin/bsdtar cve-2024-57970_libarchive-target-fixed --version
# Output: bsdtar 3.7.8 - libarchive 3.7.8
```

### 3. Exploit Doesn't Crash
```bash
python -m scripts.bench run CVE-2024-57970_libarchive --service target-vuln --seed "tasks\CVE-2024-57970_libarchive\seeds\base_truncated.tar"
# Output: exit_code=0 (NO CRASH)
```

The `base_truncated.tar` is a 3072-byte GNU longlink TAR, truncated to trigger the heap-buffer-over-read in `header_gnu_longlink()`. But it processes without any crash.

### 4. Pipeline "Successes" Are All False Positives
All previous successful iterations were due to transient Docker state corruption:
- iter_007: Pipeline reported exit_code=139, manual test shows exit_code=1
- When Docker state is clean, NO seed triggers a crash
- The new double-check validation will catch these false positives

## Root Cause Analysis

CVE-2024-57970 is a **heap-buffer-over-read** where `strlen()` reads beyond allocated buffer. This type of vulnerability:

1. **May not cause segfault** - just reads uninitialized heap memory
2. **ASan may not detect** unless:
   - Read crosses page boundary (depends on heap layout)
   - Strict checking enabled: `ASAN_OPTIONS=strict_string_checks=1`
   - Memory is explicitly poisoned by ASan

3. **The overflow is a READ, not WRITE** - less likely to crash immediately

## Pipeline Status

### Fixed Infrastructure Issues ✅
1. Docker cleanup now runs BEFORE each iteration (prevents state accumulation)
2. Verification uses subprocess calls matching manual testing
3. Double-check validation catches non-reproducible results
4. Network cleanup prevents persistent state

### Core Problem Remains ❌
**The oracle doesn't work** - we cannot distinguish vulnerable from fixed versions because neither crashes.

## Next Steps

### Option 1: Fix ASan Detection
Try stricter ASan options in Dockerfile.vuln:
```dockerfile
ENV ASAN_OPTIONS="strict_string_checks=1:detect_invalid_pointer_pairs=2:halt_on_error=1"
```

### Option 2: Use Valgrind Instead
Valgrind memcheck catches ALL invalid reads:
```bash
valgrind --tool=memcheck --error-exitcode=1 bsdtar -tf exploit.tar
```

### Option 3: Different Exploitation Approach
Current exploit is 3072-byte truncation. Maybe need:
- Different truncation point (e.g., 2048, 1024, 768 bytes)
- Specific header field corruption
- Different GNU longlink size

### Option 4: Switch CVE
Find a CVE with:
- Write overflow (not just read)
- Guaranteed segfault behavior
- Known working exploit

## Recommendation for TFM

**Cannot proceed with CVE-2024-57970** until oracle is fixed. Suggest:

1. Try Option 1 (stricter ASan) + Option 3 (different payload) first
2. If no success within 2 hours → Switch to different CVE
3. Look for CVEs with:
   - Known PoC that crashes with ASan
   - Write-based vulnerabilities (use-after-free, double-free, heap overflow with write)
   - Simpler triggering conditions

The pipeline infrastructure is now solid. Just need a working vulnerability/oracle pair.
