# CVE-2023-50246: Complete Technical Context

## Official Advisory Summary

**CVE ID:** CVE-2023-50246  
**Type:** Heap-based buffer overflow (CWE-122)  
**Component:** jq JSON processor - decimal number library  
**Function:** `decToString` in `src/decNumber/decNumber.c`

**References:**
- GitHub Advisory: GHSA-686w-5m7m-54vc
- Fix Commit: `71c2ab509a8628dbbad4bc7b3f98a64aa90d3297`
- Fixed Release: jq 1.7.1

## ⚠️ CRITICAL: This CVE is DIFFICULT for LLM Fuzzing

### Minimum Crash Requirements

To trigger the **real** heap-buffer-overflow (ASan), you need:
- **At least 338 bytes** of specific malformed input
- The content must include specific patterns from the original PoC

| Input Size | Exit Code | Result |
|------------|-----------|--------|
| 337 bytes | 0 | No crash |
| **338 bytes** | **134** | **Crash** ✓ |
| 1133 bytes (full PoC) | 134 | Crash ✓ |

### Why This is Difficult

1. **Large payload required:** 338+ bytes of hex = 676+ hex characters in mutation
2. **Specific patterns needed:** Not just any 338 bytes - must contain specific PoC patterns:
   - Leading zeros with exponents: `00000001 -001000...E-10000100`
   - Null bytes: `\x00` interspersed
   - Special chars: `\x0d`, `\x10`, `\x15`, `\x1e`
   - Text fragments: `dddddddwdd`, `l,null`
3. **UBSan vs ASan:** jq 1.7 has an inherent UBSan issue (null pointer) that triggers with ANY input but is NOT the CVE

### Mutation Strategy (Difficult)

Starting seed: `{"n": 1}` (9 bytes)

To trigger the real crash, the LLM would need to:
```json
{
  "mutations": [
    {"op": "overwrite_range", "offset": 0, "hex": "... ~676+ hex chars ..."}
  ]
}
```

This is practically impossible for an LLM to generate correctly.

## Comparison with CVE-2024-57970 (libarchive)

| Aspect | CVE-2024-57970 (libarchive) | CVE-2023-50246 (jq) |
|--------|------------------------------|---------------------|
| **Trigger** | Truncate to specific size | Generate 338+ bytes of specific content |
| **Mutation** | `{"op": "truncate", "new_len": 512}` | 676+ hex chars |
| **Difficulty** | **Easy** - just guess a number | **Very Hard** - need exact byte patterns |
| **LLM Success** | L0-L3 all work | Unlikely without PoC as seed |

## Recommendation for LLM Fuzzing

This CVE demonstrates that **not all vulnerabilities are equally amenable to LLM-guided fuzzing**:

- **Good candidates:** Size-based bugs, truncation bugs, simple structure mutations
- **Poor candidates:** Content-specific patterns, large payloads with exact byte sequences

For this CVE, using the PoC as the base seed (instead of `{"n": 1}`) would be the only practical approach for LLM fuzzing.
