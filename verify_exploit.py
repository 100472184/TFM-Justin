#!/usr/bin/env python3
"""
Quick exploit verification script for CVE-2024-57970_libarchive.
Runs a seed against both vulnerable and fixed versions and reports if it's a valid exploit.
"""
import sys
import subprocess
from pathlib import Path
from scripts.lib.utils import repo_root
from scripts.lib.oracle import looks_like_sanitizer_crash

def verify_exploit(seed_path: Path, task_id: str = "CVE-2024-57970_libarchive", rebuild: bool = False) -> dict:
    """
    Verify if a seed is a valid exploit.
    
    Args:
        seed_path: Path to the seed file
        task_id: Task identifier (default: CVE-2024-57970_libarchive)
        rebuild: If True, rebuild Docker images before testing (slow but deterministic)
    
    Returns:
        dict with keys: vuln_crashes, fixed_crashes, success, details
    """
    if not seed_path.exists():
        return {
            "error": f"Seed file not found: {seed_path}",
            "success": False
        }
    
    print(f"üîç Verifying exploit: {seed_path.name}")
    print(f"   Size: {seed_path.stat().st_size} bytes")
    
    # Rebuild images if requested (for deterministic results)
    if rebuild:
        print(f"   Rebuilding Docker images (this takes ~30-60s)...")
        rebuild_result = subprocess.run(
            [sys.executable, "-m", "scripts.bench", "build", task_id],
            capture_output=True,
            text=True,
            cwd=str(repo_root()),
            timeout=600
        )
        if rebuild_result.returncode != 0:
            print(f"   ‚ö†Ô∏è  Warning: Rebuild failed: {rebuild_result.stderr[:100]}")
        else:
            print(f"   ‚úì Images rebuilt")
    print()
    
    # Run against vulnerable version
    print("Testing vulnerable version (v3.7.7)...")
    vuln_result = subprocess.run(
        [sys.executable, "-m", "scripts.bench", "run", task_id, 
         "--service", "target-vuln", "--seed", str(seed_path)],
        capture_output=True,
        text=True,
        cwd=str(repo_root())
    )
    
    # Parse vulnerable version output
    vuln_exit_code = vuln_result.returncode
    vuln_output = vuln_result.stdout + "\n" + vuln_result.stderr
    
    # Extract actual exit code from output (bench.py prints it)
    for line in vuln_output.split('\n'):
        if 'exit_code=' in line:
            try:
                vuln_exit_code = int(line.split('exit_code=')[1].split()[0])
            except:
                pass
    
    vuln_crashes = (vuln_exit_code in [139, 134, -11, -6, 11, 6] or 
                    "AddressSanitizer" in vuln_output or
                    "heap-buffer-overflow" in vuln_output or
                    "Segmentation fault" in vuln_output)
    
    print(f"   Exit code: {vuln_exit_code}")
    print(f"   Crashes: {'YES ‚úì' if vuln_crashes else 'NO ‚úó'}")
    if vuln_crashes:
        if "AddressSanitizer" in vuln_output:
            print(f"   ASan detected: heap-buffer-overflow")
    print()
    
    # Run against fixed version
    print("Testing fixed version (v3.7.8)...")
    fixed_result = subprocess.run(
        [sys.executable, "-m", "scripts.bench", "run", task_id,
         "--service", "target-fixed", "--seed", str(seed_path)],
        capture_output=True,
        text=True,
        cwd=str(repo_root())
    )
    
    # Parse fixed version output
    fixed_exit_code = fixed_result.returncode
    fixed_output = fixed_result.stdout + "\n" + fixed_result.stderr
    
    for line in fixed_output.split('\n'):
        if 'exit_code=' in line:
            try:
                fixed_exit_code = int(line.split('exit_code=')[1].split()[0])
            except:
                pass
    
    fixed_crashes = (fixed_exit_code in [139, 134, -11, -6, 11, 6] or
                     "AddressSanitizer" in fixed_output or
                     "heap-buffer-overflow" in fixed_output or
                     "Segmentation fault" in fixed_output)
    
    print(f"   Exit code: {fixed_exit_code}")
    print(f"   Crashes: {'YES ‚ö†Ô∏è' if fixed_crashes else 'NO ‚úì'}")
    print()
    
    # Determine success
    success = vuln_crashes and not fixed_crashes
    
    # Print verdict
    print("=" * 60)
    if success:
        print("‚úÖ VALID EXPLOIT - Crashes vulnerable version only")
        print(f"   Vulnerable: exit_code={vuln_exit_code} (crashes)")
        print(f"   Fixed: exit_code={fixed_exit_code} (no crash)")
    elif vuln_crashes and fixed_crashes:
        print("‚ùå FALSE POSITIVE - Both versions crash")
        print(f"   Vulnerable: exit_code={vuln_exit_code}")
        print(f"   Fixed: exit_code={fixed_exit_code}")
    elif not vuln_crashes and not fixed_crashes:
        print("‚ùå NOT AN EXPLOIT - Neither version crashes")
        print(f"   Vulnerable: exit_code={vuln_exit_code}")
        print(f"   Fixed: exit_code={fixed_exit_code}")
    else:
        print("‚ùå INVERTED BEHAVIOR - Only fixed version crashes (unexpected)")
        print(f"   Vulnerable: exit_code={vuln_exit_code}")
        print(f"   Fixed: exit_code={fixed_exit_code}")
    print("=" * 60)
    
    return {
        "vuln_crashes": vuln_crashes,
        "vuln_exit_code": vuln_exit_code,
        "fixed_crashes": fixed_crashes,
        "fixed_exit_code": fixed_exit_code,
        "success": success,
        "seed_path": str(seed_path),
        "seed_size": seed_path.stat().st_size
    }


def main():
    import argparse
    parser = argparse.ArgumentParser(
        description="Verify if a seed is a valid exploit for CVE-2024-57970",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Quick test (may show non-determinism):
  python verify_exploit.py seed.bin
  
  # Deterministic test (rebuilds images first, slower):
  python verify_exploit.py seed.bin --rebuild
        """
    )
    parser.add_argument("seed_file", help="Path to the seed file to test")
    parser.add_argument("--rebuild", action="store_true",
                        help="Rebuild Docker images before testing (slow but deterministic)")
    
    args = parser.parse_args()
    
    seed_path = Path(args.seed_file)
    result = verify_exploit(seed_path, rebuild=args.rebuild)
    
    # Exit with appropriate code
    sys.exit(0 if result.get("success", False) else 1)


if __name__ == "__main__":
    main()
