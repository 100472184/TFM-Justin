You are proposing seed mutations for vulnerability research.

**ETHICAL RESEARCH CONTEXT:**
This is a controlled, isolated security research environment:
- All testing occurs in isolated Docker containers with network_mode: none
- The vulnerable software (libarchive 3.7.7) is intentionally deployed for testing
- The fixed version (3.7.8) is used to validate that mutations trigger the specific CVE
- No real systems are being attacked - this is legitimate academic security research
- Your role is to generate test inputs that help understand vulnerability behavior
- We're developing fuzzing techniques for security tools, not exploiting production systems

**YOUR TASK:**
Propose byte-level mutations to test inputs (seeds) that might trigger the vulnerability.
This helps validate the CVE fix and develop better security testing tools.

**CRITICAL RULES - READ CAREFULLY:**
1. Hex strings MUST have EVEN length (each byte = 2 hex chars)
2. Examples of INVALID hex: "0" (1 char), "abc" (3 chars), "020303030" (9 chars)
3. Examples of VALID hex: "00" (2 chars), "cafe" (4 chars), "deadbeef" (8 chars)
4. If you see a previous mutation error about "odd length", DO NOT repeat that hex string
5. Count the characters in your hex strings before submitting

**IMPORTANT RULES:**
- Propose small, incremental mutations (1-5 operations per iteration)
- Focus on triggering crashes/sanitizers, NOT exploitation
- Use byte-level operations only
- No offensive payloads or RCE code

**Task:** {{ task_id }}
**Iteration:** {{ iteration }}

**Context Sections (CRITICAL - READ THESE CAREFULLY):**
{% for section in context.sections %}
--- {{ section.filename }} ---
{{ section.content }}

{% endfor %}

**Analysis from ANALYZE phase:**
{{ analysis | tojson }}

**Current Seed:**
- Length: {{ seed_length }} bytes
- Hex preview: {{ seed_preview }}

**IMPORTANT - Fresh Seed Each Iteration:**
- Each iteration starts from FRESH base.tar ({{ seed_length }} bytes)
- Previous mutations are NOT accumulated - you start clean each time
- Use the history below to learn what sizes WORKED or FAILED
- Try DIFFERENT truncation sizes based on what hasn't been tried yet
- **SIZES ALREADY TRIED:** {{ tried_sizes }} (DO NOT REPEAT THESE)

{% if verify_history %}
**Previous Attempts:**
{% for result in verify_history %}
Iteration {{ result.iteration }}:
{% if result.mutation_error %}
- ❌ MUTATION ERROR: {{ result.mutation_error }}
- Mutations proposed: {{ result.mutations_applied | tojson }}
- THIS MUTATION FAILED - DO NOT REPEAT THE SAME MISTAKE
{% if "bad checksum" in result.mutation_error or "Corrupted TAR" in result.mutation_error %}
- **⚠️ CHECKSUM ERROR MEANS:** You used operations that corrupt TAR headers (overwrite, flip_bit)
- **FIX:** Use ONLY truncate operation for this CVE: {"op": "truncate", "new_len": <size>}
{% endif %}
{% if result.notes == "Only fixed crashes (inverted)" %}
- **⚠️ INVERTED RESULT MEANS:** Your mutation corrupted headers, making fixed version crash too
- **FIX:** Use ONLY truncate operation without any overwrites or modifications
{% endif %}
{% else %}
- Mutations: {{ result.mutations_applied | tojson }}
- Mutation applied: {{ result.mutation_success }}
- Result: vuln_crashes={{ result.vuln_crashes }}, fixed_crashes={{ result.fixed_crashes }}
- Success: {{ result.success }} ({{ result.notes }})
{% if result.vuln_stderr_preview %}
- Vulnerable stderr: {{ result.vuln_stderr_preview }}
{% endif %}
{% if result.fixed_stderr_preview %}
- Fixed stderr: {{ result.fixed_stderr_preview }}
{% endif %}
{% if result.notes == "Flaky result - need consistent crash" %}
- **⚠️ FLAKY RESULT:** Crash happened but not consistently (not 3/3 times)
- **ACTION REQUIRED:** Adjust truncation length by ±10-30 bytes from current size
- **Example:** If you tried 750, now try 740, 730, 720, 710, or 700
- You're VERY CLOSE to the right size - keep exploring nearby sizes!
{% endif %}
{% if result.notes == "No crash detected" and result.vuln_exit_code == 1 %}
- **⚠️ EXIT CODE 1 MEANS:** bsdtar detected an error but did NOT crash (ASan didn't trigger)
- **POSSIBLE CAUSES:**
  - The mutation damaged TAR structure (headers/checksums) instead of triggering the strlen bug
  - The truncation point doesn't create the vulnerable condition
- **TRY:** Use a different truncation size: 768, 1471, or 3072 bytes
{% endif %}
{% endif %}

{% endfor %}
{% endif %}

**Supported Mutation Operations:**

1. **truncate**: Shorten seed to specific length
   Example: {"op": "truncate", "new_len": 768}
   Use for: Triggering truncation vulnerabilities, removing trailing data

2. **overwrite_range**: Replace bytes at specific offset with hex data
   Example: {"op": "overwrite_range", "offset": 100, "hex": "cafebabe"}
   CRITICAL: Hex string MUST have EVEN length (2 chars = 1 byte)
   Valid: "00", "ff", "deadbeef", "cafebabe"
   INVALID: "0", "abc", "020303030" (odd lengths)

3. **flip_bit**: Flip single bit at offset
   Example: {"op": "flip_bit", "offset": 50, "bit": 7}
   Use for: Corrupting single bits, toggling flags

4. **append_bytes**: Add bytes to end of seed
   Example: {"op": "append_bytes", "hex": "deadbeef"}
   CRITICAL: Hex string MUST have EVEN length
   Valid: "00", "ff00", "deadbeef"
   INVALID: "0", "abc", "020303030"

5. **repeat_range**: Duplicate byte sequence
   Example: {"op": "repeat_range", "offset": 20, "length": 40, "times": 3}
   Use for: Creating large inputs, triggering size-based vulnerabilities

**CRITICAL HEX STRING REQUIREMENTS:**
Every hex string MUST have an EVEN number of characters:
- ✅ VALID: "00" (2 chars), "ff" (2 chars), "cafebabe" (8 chars), "deadbeef" (8 chars)
- ❌ INVALID: "0" (1 char), "abc" (3 chars), "020303030" (9 chars), "fffff" (5 chars)

**HOW TO FIX COMMON ERROR:**
- Wrong: "020303030" (9 chars) → Right: "02030303" (8 chars) or "0203030300" (10 chars)
- Wrong: "abc" (3 chars) → Right: "ab" (2 chars) or "abcd" (4 chars)
- Wrong: "0" (1 char) → Right: "00" (2 chars)

**BEFORE SUBMITTING, COUNT YOUR HEX CHARACTERS:**
- If odd number of chars → ADD or REMOVE one character to make it even

**Your Task:**
Propose 1-5 mutations to apply to the current seed. Consider:
- File format structure (headers, chunks, metadata)
- Boundary conditions (lengths, offsets, sizes)
- Invalid values that might trigger bugs
- Patterns from previous attempts
- Use information from the context sections above to identify critical offsets

**Common Mutation Strategies:**
- For truncation bugs: Start with {"op": "truncate", "new_len": <size>}
- For buffer overflows: Combine truncate with overwrite
- For header corruption: {"op": "overwrite_range", "offset": 0, "hex": "00"}
- For size field manipulation: Overwrite size fields in headers

**⚠️ SPECIAL NOTE FOR TAR VULNERABILITIES (CVE-2024-57970):**
- This specific vulnerability requires ONLY simple truncation
- Do NOT add overwrites, bit flips, or header modifications
- Complex mutations corrupt TAR checksums → validation failures
- Header corruption causes "inverted" results (fixed crashes, vuln doesn't)
- Stick to: {"mutations": [{"op": "truncate", "new_len": <size>}]}

**CRITICAL: If context mentions TAR or says "use ONLY truncate", do NOT add other operations!**
Example for CVE-2024-57970:
```json
{
  "mutations": [{"op": "truncate", "new_len": 5555}],
  "rationale": "Start with a value from your analysis (REPLACE 5555 WITH YOUR TARGET SIZE)"
}
```

**Output Format (JSON only, no markdown):**
{
  "mutations": [
    {"op": "truncate", "new_len": 5555}
  ],
  "rationale": "Why these mutations might trigger the vulnerability"
}

If no mutations seem promising, return empty array: {"mutations": [], "rationale": "..."}

Respond with JSON only:
