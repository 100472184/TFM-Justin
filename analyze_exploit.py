#!/usr/bin/env python3
"""
Static analysis of CVE-2024-57970 exploits based on TAR structure.
More reliable than execution-based testing due to ASan non-determinism.

CVE-2024-57970: heap-buffer-overflow in header_gnu_longlink()
Triggered by: Truncated GNU longlink/longname entries in TAR archives
"""
import sys
from pathlib import Path
from typing import Optional, Dict


def parse_octal_field(data: bytes) -> int:
    """Parse TAR octal field (null or space terminated)."""
    try:
        s = data.rstrip(b'\x00 ').decode('ascii')
        return int(s, 8) if s else 0
    except:
        return 0


def analyze_tar_structure(file_path: Path) -> Dict:
    """
    Analyze TAR structure to determine if it's a valid CVE-2024-57970 exploit.
    
    Based on official documentation:
    - GitHub issue #2415: https://github.com/libarchive/libarchive/issues/2415
    - CVE-2024-57970: Truncation in middle of GNU long linkname
    
    Returns dict with analysis results.
    """
    if not file_path.exists():
        return {"error": f"File not found: {file_path}"}
    
    file_size = file_path.stat().st_size
    
    # Minimum TAR header is 512 bytes
    if file_size < 512:
        return {
            "valid_exploit": False,
            "reason": f"Too small ({file_size} bytes) - TAR header is 512 bytes minimum"
        }
    
    with open(file_path, 'rb') as f:
        data = f.read()
    
    # Parse TAR header (POSIX ustar format)
    header = {
        "filename": data[0:100].rstrip(b'\x00').decode('ascii', errors='ignore'),
        "mode": data[100:108].rstrip(b'\x00').decode('ascii', errors='ignore'),
        "size": parse_octal_field(data[124:136]),  # Size of data section
        "type_flag": chr(data[156]) if data[156] < 128 else '?',
        "magic": data[257:263].rstrip(b'\x00').decode('ascii', errors='ignore'),
    }
    
    # Analyze exploit characteristics
    analysis = {
        "file_size": file_size,
        "header": header,
        "checks": {}
    }
    
    # Check 1: Valid TAR magic (POSIX ustar)
    is_ustar = header["magic"] in ["ustar", "ustar "]
    analysis["checks"]["valid_ustar"] = is_ustar
    
    # Check 2: GNU longlink/longname type flag
    is_gnu_long = header["type_flag"] in ['K', 'L']
    analysis["checks"]["gnu_long_entry"] = is_gnu_long
    analysis["checks"]["type_flag"] = header["type_flag"]
    
    if is_gnu_long:
        analysis["checks"]["entry_type"] = (
            "GNU longlink (symlink target > 100 chars)" if header["type_flag"] == 'K' 
            else "GNU longname (filename > 100 chars)"
        )
    
    # Check 3: Truncation detection
    # TAR structure: 512-byte header + data (rounded to 512-byte blocks)
    declared_size = header["size"]
    expected_total = 512 + ((declared_size + 511) // 512) * 512  # Header + rounded data
    
    is_truncated = file_size < expected_total
    analysis["checks"]["declared_data_size"] = declared_size
    analysis["checks"]["expected_total_size"] = expected_total
    analysis["checks"]["is_truncated"] = is_truncated
    
    if is_truncated:
        missing_bytes = expected_total - file_size
        analysis["checks"]["missing_bytes"] = missing_bytes
        analysis["checks"]["truncation_percent"] = (missing_bytes / expected_total) * 100
    
    # Final verdict based on CVE-2024-57970 characteristics
    is_valid_exploit = (
        is_ustar and 
        is_gnu_long and 
        is_truncated and
        declared_size > 0  # Must declare some data that's missing
    )
    
    analysis["valid_exploit"] = is_valid_exploit
    
    if is_valid_exploit:
        analysis["reason"] = (
            f"Valid CVE-2024-57970 exploit: GNU {header['type_flag']} entry "
            f"with truncated data ({file_size}/{expected_total} bytes)"
        )
    elif not is_ustar:
        analysis["reason"] = f"Not a valid TAR (magic: {header['magic']!r})"
    elif not is_gnu_long:
        analysis["reason"] = f"Not a GNU long entry (type: {header['type_flag']!r}, need 'K' or 'L')"
    elif not is_truncated:
        analysis["reason"] = f"Not truncated (complete file: {file_size} bytes)"
    else:
        analysis["reason"] = "Unknown - does not match exploit pattern"
    
    return analysis


def print_analysis(analysis: Dict, verbose: bool = True):
    """Pretty-print analysis results."""
    if "error" in analysis:
        print(f"‚ùå Error: {analysis['error']}")
        return
    
    print("=" * 70)
    print("CVE-2024-57970 Exploit Analysis (Structure-Based)")
    print("=" * 70)
    
    print(f"\nüìÑ File Information:")
    print(f"   Size: {analysis['file_size']} bytes")
    
    if verbose:
        h = analysis['header']
        print(f"\nüì¶ TAR Header:")
        print(f"   Filename: {h['filename']}")
        print(f"   Mode: {h['mode']}")
        print(f"   Type flag: '{h['type_flag']}' (0x{ord(h['type_flag']):02X})")
        print(f"   Magic: {h['magic']!r}")
        print(f"   Declared data size: {h['size']} bytes")
    
    checks = analysis['checks']
    print(f"\nüîç Exploit Characteristics:")
    print(f"   ‚úì Valid USTAR format: {'YES' if checks.get('valid_ustar') else 'NO'}")
    print(f"   ‚úì GNU long entry (K/L): {'YES' if checks.get('gnu_long_entry') else 'NO'}")
    
    if checks.get('gnu_long_entry'):
        print(f"      ‚Üí {checks.get('entry_type', 'Unknown')}")
    
    print(f"   ‚úì File is truncated: {'YES' if checks.get('is_truncated') else 'NO'}")
    
    if checks.get('is_truncated'):
        print(f"      ‚Üí Expected: {checks['expected_total_size']} bytes")
        print(f"      ‚Üí Actual: {analysis['file_size']} bytes")
        print(f"      ‚Üí Missing: {checks['missing_bytes']} bytes ({checks['truncation_percent']:.1f}%)")
    
    print(f"\n{'=' * 70}")
    if analysis['valid_exploit']:
        print("‚úÖ VALID EXPLOIT (matches CVE-2024-57970 pattern)")
        print(f"   {analysis['reason']}")
        print("\nüìö Technical Details:")
        print("   - Vulnerability: heap-buffer-overflow in header_gnu_longlink()")
        print("   - Affected: libarchive v3.7.5 - v3.7.7")
        print("   - Root cause: Missing error check after read_body_to_string()")
        print("   - Trigger: strlen() on incomplete GNU longlink data")
    else:
        print("‚ùå NOT A VALID EXPLOIT")
        print(f"   {analysis['reason']}")
    print("=" * 70)


def main():
    import argparse
    parser = argparse.ArgumentParser(
        description="Static analysis of CVE-2024-57970 exploits (structure-based, no execution)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
This tool analyzes TAR structure without executing anything, making it:
  - Deterministic (no ASan non-determinism issues)
  - Fast (no Docker/compilation needed)  
  - Reliable (based on CVE documentation)

Based on:
  - CVE-2024-57970: heap-buffer-overflow in header_gnu_longlink()
  - GitHub issue #2415: https://github.com/libarchive/libarchive/issues/2415

Examples:
  python analyze_exploit.py seed.bin
  python analyze_exploit.py seed.bin --quiet
        """
    )
    parser.add_argument("seed_file", help="Path to the seed file to analyze")
    parser.add_argument("-q", "--quiet", action="store_true",
                        help="Minimal output (only verdict)")
    
    args = parser.parse_args()
    
    seed_path = Path(args.seed_file)
    analysis = analyze_tar_structure(seed_path)
    
    if args.quiet:
        if analysis.get("valid_exploit"):
            print(f"‚úÖ VALID: {seed_path.name}")
            sys.exit(0)
        else:
            print(f"‚ùå INVALID: {seed_path.name} - {analysis.get('reason', 'Unknown')}")
            sys.exit(1)
    else:
        print_analysis(analysis, verbose=True)
        sys.exit(0 if analysis.get("valid_exploit") else 1)


if __name__ == "__main__":
    main()
